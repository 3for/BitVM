<script type="module">
	import { connect } from '../server/socket.js'
	import {
		protocol, 
		MSG_TYPE_HAND,
		USER_PAUL,
		USER_VICKY
	} from './protocol.js'

	import { runVM } from './vm.js'
	import { Player, Opponent } from '../scripts/player.js'
	import { bitvmSequence, LOG_TRACE_LEN } from '../transactions/bitvm.js'
	import { fetchUnspentOutputs } from '../libs/esplora.js'
	import { fetchJson } from '../libs/common.js'
	import { program, data } from './dummy-program.js'
    import { compileSequence } from '../transactions/transaction.js'
	import * as Esplora from '../libs/esplora.js'
    import { startListening } from './client.js'
	import { TRACE_CHALLENGE, TRACE_RESPONSE } from '../transactions/binary-search-sequence.js'

	const vickyJson = await fetchJson('vicky.json')

    const paul  = new Player('d898098e09898a0980989b980809809809f09809884324874302975287524398')
	const vicky = new Opponent(vickyJson)

    window.paul = paul
    window.vicky = vicky

	const sequence = bitvmSequence(vicky, paul, program)


	console.log('Trying to fetch an output...')

    const fundingAddress = 'tb1p9evrt83ma6e2jjc9ajagl2h0kqtz5y05nutg2xt2tn9xjcm29t0slwpyc9'
    const outpoint = (await fetchUnspentOutputs( fundingAddress )).filter(utxo => utxo.value == 1_000_000)[0]
    if(!outpoint) throw `You have to charge the contract with 1'000'000 sats! \n ${fundingAddress}`

    const finalAddress = 'tb1pq7u2ujdvjzsy36d4xdt6yd2txv6wnj97aqf7ewvwnxn7ql5v8w3sg98j36'

    console.log('Compiling the sequence...')
    const txs = compileSequence(sequence, outpoint, finalAddress)

   

    const txsMap = txs.reduce((accu, tx, index) => {
    	accu[tx.txid()] = {
    		tx,
    		index,
    		successor : txs[index + 1],
    	}
    	return accu
    },{})

	window.txsMap = txsMap


	const trace = runVM(program, data)

    startListening(async txid => {
		console.log(txid)

		const nextTx = txsMap[txid]
		if(!nextTx) 
			return

		console.log(`Observed Tx ${txid}`)

		const txHex = await Esplora.fetchTransaction(txid, 'hex')
		console.log(txHex)

		// Parse script parameters from transaction witness
		vicky.processTx(txHex)

		if( (nextTx.index % 2) )
			return

		const roundIndex = nextTx.index / 2

		let traceIndex = 0 
		for (var i = 0; i < roundIndex; i++) {
			const bit = vicky.state.get_u1( TRACE_CHALLENGE(i) )
			traceIndex += bit * 2 ** (LOG_TRACE_LEN - i)
		}
		traceIndex += 2 ** (LOG_TRACE_LEN - roundIndex)

		const root = trace.getRoot(traceIndex)
		await nextTx.successor.getLeaf(0).execute( root )
		
	})




	// const socket = await connect(USER_PAUL)

	// socket.onmessage = (clientId, msg) => {
	// 	switch(msg.type){

	// 		default:
	// 			protocol(socket, clientId, msg)
	// 	}
	// }

	// socket.sendTo(USER_VICKY, { type: MSG_TYPE_HAND })






</script>