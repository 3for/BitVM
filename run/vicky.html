<script type="module">
    import {connect} from '../server/socket.js'
	import {
		protocol, 
		MSG_TYPE_HAND,
		USER_PAUL,
		USER_VICKY
	} from './protocol.js'

	import { Player, Opponent } from '../scripts/player.js'
	import { bitvmSequence, LOG_TRACE_LEN } from '../transactions/bitvm.js'
	import { fetchUnspentOutputs } from '../libs/esplora.js'
	import { fetchJson } from '../libs/common.js'
	import { program, data } from './dummy-program.js'
    import { compileSequence } from '../transactions/transaction.js'
    import { TRACE_CHALLENGE, TRACE_RESPONSE } from '../transactions/binary-search-sequence.js'
	import { runVM } from './vm.js'
	import { parseLeafId } from './protocol.js'
	
	 

    import {startListening} from './client.js'
	import * as Esplora  from '../libs/esplora.js'

	const paulJson = await fetchJson('paul.json')

	const vicky = new Player('a9bd8b8ade888ed12301b21318a3a73429232343587049870132987481723497')
	const paul = new Opponent(paulJson)

	window.vicky = vicky
	window.paul = paul
	
	const sequence = bitvmSequence(vicky, paul, program)


	console.log('Trying to fetch an output...')

    const fundingAddress = 'tb1p9evrt83ma6e2jjc9ajagl2h0kqtz5y05nutg2xt2tn9xjcm29t0slwpyc9'
    const outpoint = (await fetchUnspentOutputs( fundingAddress )).filter(utxo => utxo.value == 1_000_000)[0]
    if(!outpoint) throw `You have to charge the contract with 1'000'000 sats! \n ${fundingAddress}`

    const finalAddress = 'tb1pq7u2ujdvjzsy36d4xdt6yd2txv6wnj97aqf7ewvwnxn7ql5v8w3sg98j36'

    console.log('Compiling the sequence...')
    const txs = compileSequence(sequence, outpoint, finalAddress)


    const txsMap = txs.reduce((accu, tx, index) => {
    	accu[tx.txid()] = {
    		tx,
    		index,
    		successor : txs[index + 1],
    	}
    	return accu
    },{})

    window.txsMap = txsMap

    const trace = runVM(program, data)

    startListening(async txid => {
		console.log(txid)

		const nextTx = txsMap[txid]
		if(!nextTx) 
			return

		console.log(`Observed Tx ${txid}`)

		const txHex = await Esplora.fetchTransaction(txid, 'hex')

		// Parse script parameters from transaction witness
		paul.processTx(txHex)

		const leafId = parseLeafId(txHex)

		if( !(nextTx.index % 2) )
			return

		const roundIndex = (nextTx.index - 1) / 2 
		const theirRoot = paul.state.get_u160( TRACE_RESPONSE(roundIndex) )
		
		let traceIndex = 0
		for (var i = 0; i < roundIndex; i++) {
			const bit = vicky.state.get_u1( TRACE_CHALLENGE(i) )
			traceIndex += bit * 2 ** (LOG_TRACE_LEN - i)
		}
		traceIndex += 2 ** (LOG_TRACE_LEN - roundIndex)

		const ourRoot = trace.getRoot(traceIndex)
		const isCorrect = Number(theirRoot === ourRoot)

		await nextTx.successor.getLeaf(0).execute(isCorrect)

	})


	txs[0].getLeaf(0).execute()

	// const socket = await connect(USER_VICKY)
	// socket.onmessage = (clientId, msg) => protocol(socket, clientId, msg)
	// socket.sendTo(USER_PAUL, { type: MSG_TYPE_HAND })
</script>
