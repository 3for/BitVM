<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bitcoin Script Interpreter</title>
    <style>
        html, body{
            font-family: system-ui, sans-serif;
            text-rendering: optimizeLegibility;
            -webkit-font-smoothing: antialiased;
        }

        body{
            padding: 8px 48px;
            background: #282828;
            color: white;
        }

        h1{
            display: flex;
            align-items: baseline;
            white-space: pre;
            height: 32px;
        }

        .version:before{
            content: 'Version: ';
            font-weight: normal;
        }

        .version {
            font-size: 13px;
            color: rgba(255,255,255,0.7);
            font-family: monospace;
            margin-left: 32px;
            flex-grow: 1;
            text-align: right;
            letter-spacing: 0.1em;
        }

        .stats{
            white-space: pre;
            font-size: 13px;
            font-family: monospace;
            margin: 8px 0 48px;
        }


        pre.error{
            color: #fe807f;
            background: #4e3534;
            padding: 2px 8px;
        }

        button{
            background: none;
            color: #5ad5fb;
            font-size:15px;
            display: flex;
            width: 160px;
            height: 32px;
            justify-content: center;
            align-items: center;
            outline: none;
            border: 1px solid #5ad5fb;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            margin-top: 48px;
        }

        .stack > span{
            font-family: monospace;
            margin-right: 8px;
            line-height: 22px;
            font-size: 15px;
            color: #5ad5fb;
        }

        .stack.grouped > span:nth-child(4n):after {
            content: '\a';
            white-space: pre;
        }

        .stack:not(.grouped){
            display: flex;
            flex-direction: column;
        }

        .stack.grouped{
            line-height: 28px;
        }

        .stack.grouped > span{
            margin-right: 5px;
        }

        .examples {
            font-size: 15px;
            color: #5ad5fb;
            flex-grow: 1;
            text-align: right;
            text-decoration: none;
            font-weight: normal;
        }

        .examples:hover{
            text-decoration: underline;
        }
    </style>
</head>
<script src="../opcodes/utils.js"></script>
<script src="../opcodes/ripemd.js"></script>
<script src="../opcodes/u32/u32_std.js"></script>
<script src="../opcodes/u32/u32_rrot7.js"></script>
<script src="../opcodes/u32/u32_rrot8.js"></script>
<script src="../opcodes/u32/u32_rrot16.js"></script>
<script src="../opcodes/u32/u32_rrot12.js"></script>
<script src="../opcodes/u32/u32_zip.js"></script>
<script src="../opcodes/u32/u32_add.js"></script>
<script src="../opcodes/u32/u32_xor.js"></script>
<script src="../opcodes/u32/u32_state.js"></script>
<script src="../opcodes/u160/u160_std.js"></script>
<script type="module">
    import init, { run_script, script_asm_to_hex } from './bitcoin_scriptexec.js';
init()

const sha256 = async buffer => {
    let hash = await window.crypto.subtle.digest('SHA-256', buffer);
    return Array.from(new Uint8Array(hash));
}

const hashText = async data => {
    let buffer = new TextEncoder().encode(data.toString())
    return toHex(await sha256(buffer))
}

const toHex = byteArray => {
    return byteArray.map(byte => ('0' + (byte & 0xFF).toString(16)).slice(-2)).join('');
}

function groupInFours(arr) {
  return arr.reduce((result, item, index) => {
    const groupIndex = Math.floor(index / 4);
    if (!result[groupIndex]) {
      result[groupIndex] = [];
    }
    result[groupIndex].push(item);
    return result;
  }, []).map( group => group.join(' ') );
}

function fmtBytes(byteCount) {
  if (byteCount < 1000) return byteCount + ' B';

  const kiloBytes = byteCount / 1024;
  if (kiloBytes < 10) return kiloBytes.toFixed(2) + ' kB';
  if (kiloBytes < 100) return kiloBytes.toFixed(1) + ' kB';
  if (kiloBytes < 1000) return Math.round(kiloBytes) + ' kB';

  const megaBytes = kiloBytes / 1024;
  if (megaBytes < 10) return megaBytes.toFixed(2) + ' MB';

  return megaBytes.toFixed(1) + ' MB';
}




let directoryHandle;
let fileHandles = new Map();
let fileVersions = new Map();

window.selectDirectory = async function() {
    // Requesting user to select a directory
    directoryHandle = await window.showDirectoryPicker();
    watchDirectory(directoryHandle);
    document.body.innerHTML = `<h1>Watching for changes in <q><i>${directoryHandle.name}</i></q>...</h1><h3>Edit and save any file in this folder to execute it</h3>`
}

async function watchDirectory(directoryHandle) {
    // Going through all entries in the directory
    for await (const entry of directoryHandle.values()) {
        if (entry.kind === 'file') {
            // Saving file handles and their last modified time
            const file = await entry.getFile();
            fileHandles.set(entry.name, entry);
            fileVersions.set(entry.name, file.lastModified);
        } 
    }

    // Polling for changes
    setInterval(async () => {
        for await (const entry of directoryHandle.values()) {
            if (entry.kind === 'file') {
                const file = await entry.getFile();
                const lastModified = fileVersions.get(entry.name) || 0;

                // Checking if the file was updated
                if (file.lastModified > lastModified) {
                    fileHandles.set(entry.name, entry);
                    fileVersions.set(entry.name, file.lastModified);
                    updateFunction(entry);
                }
            }
        }
    }, 500); // Checking for changes every 500ms
}

function compile(text){
    let code = eval(text)
    if( Array.isArray(code) ){
        code = code.flat(50).join(' ')
    }
    code = code.split('debug;')[0]
    return code
}

async function updateFunction(updatedFileHandle) {
    try {
        // Getting the File object from the file handle
        const file = await updatedFileHandle.getFile()

        // Reading the content of the file
        const text = await file.text()

        // Logging the content of the file
        console.log('File Updated:', updatedFileHandle.name)
        document.body.innerHTML = `<h1>Running <i><q>${updatedFileHandle.name}</q></i> <b id="$version" class="version"><b></h1>`
        const code = compile(text)
        const hash = await hashText(code)
        const result = await run_script(code)
        $version.textContent += hash.substr(0, 8)
        console.log(result)
        const stack = result.get('final_stack')
            .map(item => !item ? '00' : item)
            .map(item => (item.length == 4 && item.substr(2) == '00') ? item.substr(0,2) : item )
            .reverse()
        console.log(stack)

        const groupedStack = stack.reduce( (a,e) => a + `<span title="${Number('0x'+e)}">${e}</span>`, '')

        const error = result.get('error')
        if(error){
            document.body.innerHTML += `<pre class="error">Error: ${error}\n${stack.join('\n')}</pre>`
            return
        }
        const compiledCode = script_asm_to_hex(code)
        const scriptSize = fmtBytes(compiledCode.length / 2)
        const stackSize = result.get('stats').get('max_stack_size')
        
        document.body.innerHTML += `<div class="stats">
script size: <b 
    title="The byte size of the compiled script"
>${scriptSize}</b>  |  max depth: <b 
    title="Maximum number of items on the stack over the course of the entire execution."
>${stackSize}</b> items  |  <label
>u32 groups: <input type="checkbox" oninput="toggleGrouping()" ${isGrouped?'checked':''}></label>
</div>`


        document.body.innerHTML += `<h3>Resulting Stack</h3><div class="stack ${isGrouped?'grouped':''}" id="$stack">${groupedStack}</div>`

    } catch (error) {
        document.body.innerHTML += `<pre class="error">${error}</pre>`
        console.error('Error reading file:', error)
    }
}

let isGrouped = true

window.toggleGrouping = _ => {
    $stack.classList.toggle('grouped')
    isGrouped = !isGrouped
}

</script>

<body>
    <h1>Bitcoin Script Interpreter
        <a href="https://github.com/BitVM/BitVM/tree/main/opcodes/examples" class="examples" target="_blank" title="Example code to download and edit">Examples</a>
    </h1>
    <h3>Select a folder to run Bitcoin Scripts</h3>
    <button onclick="selectDirectory()" autofocus>Select Directory</button>
</body>

</html>