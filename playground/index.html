<!-- <script src='https://bundle.run/noble-secp256k1@1.2.14'></script> -->
<script src="https://unpkg.com/@cmdcode/tapscript"></script>
<script src="https://unpkg.com/@cmdcode/crypto-tools"></script>

<script type="module">
    import init, { run_script, script_asm_to_hex } from '../libs/bitcoin_scriptexec.js';
    import { hashLock, preimageHex, bit_state_commit, bit_state_unlock } from '../opcodes/u32/u32_state.js';
    import { preprocessJS } from '../opcodes/compile.js';
    import { toHex } from '../libs/bytes.js';
    import { u160_state_commit, u160_state_commit_unlock } from '../opcodes/u160/u160_std.js';
    import { broadcastTransaction } from '../libs/esplora.js';
    
    await init();
    
    const { Tap, Tx, Address, Script, Signer } = tapscript

    function compile(program){
        return Script.decode(script_asm_to_hex(preprocessJS(program)))
    }

    function replace_unlock_opcodes(script) {
        return script.map(opcode => {
            switch (opcode) {
                case 'OP_1':
                    return '01'
                case 'OP_2':
                    return '02'
                case 'OP_3':
                    return '03'
                default:
                    return opcode
            }
        })
    }

    function compileUnlock(program){
        return replace_unlock_opcodes(compile(program))
    }


    const paul = {
        secret: 'd898098e09898a0980989b980809809809f09809884324874302975287524398',
    }
    paul.seckey = crypto_tools.keys.get_seckey(paul.secret)
    // Drop the first byte of the pubkey
    paul.pubkey = toHex(crypto_tools.keys.get_pubkey(paul.seckey)).slice(2)

    const vicky = {
        secret: 'a9bd8b8ade888ed12301b21318a3a73429232343587049870132987481723497',
    }
    vicky.seckey = crypto_tools.keys.get_seckey(vicky.secret)
    vicky.pubkey = toHex(crypto_tools.keys.get_pubkey(vicky.seckey)).slice(2)

    // Challenge transaction script (1-bit commitment)
    const challenge_script = compile([
        bit_state_commit(vicky.secret, 'challenge'), 
        paul.pubkey,
        OP_CHECKSIG
    ])
    const challenge_tapleaf = Tap.encodeScript(challenge_script)
    const [ challenge_tpubkey, challenge_cblock ] = Tap.getPubKey(paul.pubkey, {target: challenge_tapleaf})
    const challenge_address = Address.p2tr.fromPubKey(challenge_tpubkey, 'signet')
    console.log('CHALLENGE ADDRESS TO FUND', challenge_address)

    // Response transaction script (160bit commitment)
    const response_script = compile([
        u160_state_commit(paul.secret, 'response'),
        vicky.pubkey, 
        OP_CHECKSIG
    ])

    const response_tapleaf = Tap.encodeScript(response_script)
    const [response_tpubkey, response_cblock] = Tap.getPubKey(vicky.pubkey, {target: response_tapleaf})
    const response_address = Address.p2tr.fromPubKey(response_tpubkey, 'signet')


    // Send a transaction to the challenge address with 100k sats and fill in the id here.
    const funding_txid = '76c27c06f82b14195a09cdc0c8ab049f2e0ac6207620b2fabaf54dfe637cbc0a'

    // Challenge transaction
    const challenge_tx = Tx.create({
        vin: [{
            // The txid of your funding transaction.
            txid: funding_txid,
            // Fill in the correct vout (likely 0 or 1) of the funding transaction here.
            vout: 1,
            // For Taproot, we need to specify this data when signing.
            prevout: {
                // The value of the output we are spending.
                value: 100_000,
                // This is the script that our taproot address decodes into.
                scriptPubKey: [OP_1, challenge_tpubkey]
            },
        }],
        vout: [{
            // We are locking up 99_000 sats (minus 1000 sats for fees.)
            value: 99_000,
            // We are locking up funds to this address.
            scriptPubKey: Address.toScriptPubKey(response_address)
        }]
    })

    const challenge_txhex_unsigned = Tx.encode(challenge_tx).hex
    const challenge_txid = Tx.util.getTxid(challenge_txhex_unsigned)
    console.log('CHALLENGE TXID', challenge_txid)

    // Response transaction
    const response_tx = Tx.create({
        vin: [{
            // The txid of the previous challenge tx.
            txid: challenge_txid,
            // The index of the output you are spending.
            vout: 0,
            // For Taproot, we need to specify this data when signing.
            prevout: {
                // The value of the output we are spending.
                value: 99_000,
                // This is the script that our taproot address decodes into.
                scriptPubKey: Address.toScriptPubKey(response_address)
            },
        }],
        vout: [{
            value: 90_000,
            // Lock up funds to arbitrary address to not burn them. TODO next challenge address
            scriptPubKey: Address.toScriptPubKey(challenge_address)
        }]
    })

    const response_txhex_unsigned = Tx.encode(response_tx).hex
    const response_txid = Tx.util.getTxid(response_txhex_unsigned)
    console.log('RESPONSE TXID', response_txid)

    // Vicky signs Paul's response transaction
    const response_sig = Signer.taproot.sign(vicky.seckey, response_tx, 0, { extension: response_tapleaf })
    // Paul presigns Vicky's challenge transaction
    const challenge_sig = Signer.taproot.sign(paul.seckey, challenge_tx, 0, { extension: challenge_tapleaf })

    // Vicky reveals the bit-commitment preimage for value '0' here in the witness.
    challenge_tx.vin[0].witness = [challenge_sig.hex, bit_state_unlock(vicky.secret, 'challenge', 0), challenge_script, challenge_cblock]
    const challenge_txhex = Tx.encode(challenge_tx).hex

    // Paul reveals the u160 bit-commitment preimages for value '0xdeadbeefdeadbeefdeadbeefdeadbeefdeadbeef'
    const unlock_values = compileUnlock( u160_state_commit_unlock(paul.secret, 'response', 'deadbeefdeadbeefdeadbeefdeadbeefdeadbeef'))
    response_tx.vin[0].witness = [response_sig.hex, ...unlock_values, response_script, response_cblock]
    const response_txhex = Tx.encode(response_tx).hex

    // console.log('Challenge TX broadcasted', await broadcastTransaction(challenge_txhex) )
    // console.log('Response TX broadcasted', await broadcastTransaction(response_txhex) )
</script>
